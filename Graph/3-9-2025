// BFS in graph 
class Solution {
    // Function to return Breadth First Search Traversal of given graph.
    
    public ArrayList<Integer> bfs(ArrayList<ArrayList<Integer>> adj) {
        // code here
        boolean visited[] = new boolean[adj.size()];
        ArrayList<Integer> ans = new ArrayList<>();
        Queue<Integer> q = new LinkedList<>();  
        int s =0;
        visited[s]= true;
        q.add(s);
        while(!q.isEmpty()){
            int curr = q.poll();
            ans.add(curr);
            for(int x : adj.get(curr)){
                if(!visited[x]){
                    q.add(x);
                    visited[x]=true;
                }
            }
            
        }
        return ans;
    }
}

// DfS in graph 
class Solution {
    // Function to return a list containing the DFS traversal of the graph.
    public ArrayList<Integer> dfs(ArrayList<ArrayList<Integer>> adj) {
        // Code hre
        int v = adj.size();
        ArrayList<Integer> list = new ArrayList<>();
        boolean vis[] = new boolean[v];
        Dfs(adj,0,vis,list);
        return list;
    }
    public static void Dfs(ArrayList<ArrayList<Integer>> adj,int node,boolean vis[],ArrayList<Integer> list){
        vis[node] = true;
        list.add(node);
        for(int i:adj.get(node)){
            if(!vis[i]){
                Dfs(adj,i,vis,list);
            }
        }
    }
}

// shortest path
class Solution {
    public int minStep(int n) {
        Queue<int []> q = new LinkedList<>();
        boolean visited[] = new boolean[n+1];
        q.add(new int[]{1,0});
        visited[1] = true;
        while(!q.isEmpty()){
            int[] curr = q.poll();
            int val = curr[0];
            int steps = curr[1]; 
            if(val==n){
                return steps;
            }
            int next1 = val + 1;
            int next2 = val * 3;

            if (next1 <= n && !visited[next1]) {
                visited[next1] = true;
                q.add(new int[]{next1, steps + 1});
            }
            if (next2 <= n && !visited[next2]) {
                visited[next2] = true;
                q.add(new int[]{next2, steps + 1});
            }
        }
        return -1;
    }
}


// count the number of islands
class Solution {
    public int countIslands(char[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        int count = 0;
        int[] dr = {-1, -1, -1, 0, 0, 1, 1, 1};
        int[] dc = {-1, 0, 1, -1, 1, -1, 0, 1};
        for (int i = 0; i < n; i++){
            for (int j = 0; j < m; j++){
                if (grid[i][j] == 'L') {
                    count++;
                    dfs(grid, i, j, n, m, dr, dc);
                }
            }
        }
        return count;
    }

    void dfs(char[][] grid, int r, int c, int n, int m, int[] dr, int[] dc){
        if (r < 0 || r >= n || c < 0 || c >= m || grid[r][c] != 'L') {
            return;
        }
        grid[r][c] = 'W';
        for (int i = 0; i < 8; i++) {
            dfs(grid, r + dr[i], c + dc[i], n, m, dr, dc);
        }
    }
}
